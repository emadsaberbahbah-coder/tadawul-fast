# core/data_engine_v2.py

from __future__ import annotations

import asyncio
import logging
import os
import time
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional, Tuple

import httpx
from pydantic import BaseModel, Field

try:
    # Python 3.11+
    from zoneinfo import ZoneInfo
except Exception:  # pragma: no cover
    ZoneInfo = None  # type: ignore

logger = logging.getLogger(__name__)

# ============================================================
# Optional integration with env.py (central settings)
# ============================================================

try:  # pragma: no cover - best-effort
    import env as _env_mod  # type: ignore

    _SETTINGS = getattr(_env_mod, "settings", None)
except Exception:  # pragma: no cover
    _env_mod = None  # type: ignore
    _SETTINGS = None

# ============================================================
# Optional integration with v1 engine (core.data_engine)
# Used mainly for KSA / Tadawul-safe delegation
# ============================================================

try:  # pragma: no cover - best-effort
    from core import data_engine as _v1_engine  # type: ignore

    _HAS_V1_ENGINE = True
except Exception:  # pragma: no cover
    _v1_engine = None  # type: ignore
    _HAS_V1_ENGINE = False


# ============================================================
# MODELS
# ============================================================

class ProviderSource(BaseModel):
    provider: str
    weight: Optional[float] = None
    quality: Optional[float] = None
    note: Optional[str] = None


class UnifiedQuote(BaseModel):
    """
    Unified quote model used across:
      - /v1/enriched
      - /v1/analysis
      - /v1/advanced (if enabled)
      - legacy /sheet-rows builders

    It is intentionally rich (identity + price + fundamentals + scores),
    but only a subset is filled depending on provider data.
    """

    # Identity
    symbol: str = Field(..., description="Canonical symbol, e.g. 1120.SR, AAPL")
    name: Optional[str] = None
    company_name: Optional[str] = None
    sector: Optional[str] = None
    sub_sector: Optional[str] = None
    industry: Optional[str] = None
    market: Optional[str] = None
    market_region: Optional[str] = None
    exchange: Optional[str] = None
    currency: Optional[str] = None
    listing_date: Optional[str] = None

    # Capital structure
    shares_outstanding: Optional[float] = None
    free_float: Optional[float] = None

    # Price / liquidity
    last_price: Optional[float] = None
    price: Optional[float] = None
    previous_close: Optional[float] = None
    prev_close: Optional[float] = None
    open: Optional[float] = None
    high: Optional[float] = None
    low: Optional[float] = None
    change: Optional[float] = None
    change_percent: Optional[float] = None
    change_pct: Optional[float] = None

    high_52w: Optional[float] = None
    low_52w: Optional[float] = None
    fifty_two_week_high: Optional[float] = None
    fifty_two_week_low: Optional[float] = None
    position_52w_percent: Optional[float] = None
    fifty_two_week_position: Optional[float] = None

    volume: Optional[float] = None
    avg_volume_30d: Optional[float] = None
    average_volume_30d: Optional[float] = None
    avg_volume: Optional[float] = None
    value_traded: Optional[float] = None
    turnover_rate: Optional[float] = None
    bid_price: Optional[float] = None
    ask_price: Optional[float] = None
    bid_size: Optional[float] = None
    ask_size: Optional[float] = None
    spread_percent: Optional[float] = None
    liquidity_score: Optional[float] = None

    # Fundamentals
    eps_ttm: Optional[float] = None
    eps: Optional[float] = None
    pe_ratio: Optional[float] = None
    pe: Optional[float] = None
    pe_ttm: Optional[float] = None
    pb_ratio: Optional[float] = None
    pb: Optional[float] = None
    dividend_yield_percent: Optional[float] = None
    dividend_yield: Optional[float] = None
    dividend_payout_ratio: Optional[float] = None
    roe_percent: Optional[float] = None
    roe: Optional[float] = None
    roa_percent: Optional[float] = None
    roa: Optional[float] = None
    debt_to_equity: Optional[float] = None
    current_ratio: Optional[float] = None
    quick_ratio: Optional[float] = None
    market_cap: Optional[float] = None

    # Growth / profitability
    revenue_growth_percent: Optional[float] = None
    net_income_growth_percent: Optional[float] = None
    ebitda_margin_percent: Optional[float] = None
    operating_margin_percent: Optional[float] = None
    net_margin_percent: Optional[float] = None
    profit_margin: Optional[float] = None

    # Valuation / risk
    ev_to_ebitda: Optional[float] = None
    price_to_sales: Optional[float] = None
    price_to_cash_flow: Optional[float] = None
    peg_ratio: Optional[float] = None
    beta: Optional[float] = None
    volatility_30d_percent: Optional[float] = None
    volatility_30d: Optional[float] = None

    # AI valuation & scores
    fair_value: Optional[float] = None
    upside_percent: Optional[float] = None
    valuation_label: Optional[str] = None
    value_score: Optional[float] = None
    quality_score: Optional[float] = None
    momentum_score: Optional[float] = None
    opportunity_score: Optional[float] = None
    recommendation: Optional[str] = None

    # Technicals
    rsi_14: Optional[float] = None
    macd: Optional[float] = None
    ma_20d: Optional[float] = None
    ma_50d: Optional[float] = None

    # Meta & providers
    data_quality: str = Field(
        "UNKNOWN", description="OK / PARTIAL / MISSING / STALE / UNKNOWN"
    )
    primary_provider: Optional[str] = None
    provider: Optional[str] = None
    data_source: Optional[str] = None
    sources: Optional[List[ProviderSource]] = None

    # Timestamps
    last_updated_utc: Optional[datetime] = None
    last_updated_riyadh: Optional[datetime] = None
    as_of_utc: Optional[datetime] = None
    as_of_local: Optional[datetime] = None
    timezone: Optional[str] = None

    # Raw / errors
    error: Optional[str] = None
    raw: Optional[Dict[str, Any]] = None


@dataclass
class _CacheEntry:
    expires_at: float
    quote: UnifiedQuote


# ============================================================
# CORE ENGINE
# ============================================================

class DataEngine:
    """
    Core async engine used by:
      - routes.enriched_quote
      - routes.ai_analysis
      - legacy_service (if v2 is present)

    It is:
      - KSA-safe (never calls EODHD for .SR / .TADAWUL)
      - Integrated with env.py settings (if available)
      - Backwards compatible with core.data_engine (v1)
    """

    def __init__(
        self,
        cache_ttl: Optional[int] = None,
        provider_timeout: Optional[int] = None,
        enabled_providers: Optional[List[str]] = None,
        enable_advanced_analysis: Optional[bool] = None,
    ) -> None:
        # -------------------------
        # Cache TTL
        # -------------------------
        if cache_ttl is not None:
            self.cache_ttl = cache_ttl
        elif _SETTINGS is not None:
            self.cache_ttl = int(
                getattr(_SETTINGS, "engine_cache_ttl_seconds", 300) or 300
            )
        else:
            # Backwards-compat env names
            self.cache_ttl = int(
                os.getenv("ENGINE_CACHE_TTL_SECONDS")
                or os.getenv("DATAENGINE_CACHE_TTL", "120")
            )

        # -------------------------
        # HTTP timeout
        # -------------------------
        if provider_timeout is not None:
            self.provider_timeout = provider_timeout
        elif _SETTINGS is not None:
            self.provider_timeout = int(getattr(_SETTINGS, "http_timeout", 10) or 10)
        else:
            self.provider_timeout = int(
                os.getenv("HTTP_TIMEOUT") or os.getenv("DATAENGINE_TIMEOUT", "10")
            )

        # -------------------------
        # Advanced analysis flag
        # -------------------------
        if enable_advanced_analysis is not None:
            self.enable_advanced_analysis = enable_advanced_analysis
        elif _SETTINGS is not None:
            self.enable_advanced_analysis = bool(
                getattr(_SETTINGS, "engine_enable_advanced_analysis", True)
            )
        else:
            raw = os.getenv("ENGINE_ENABLE_ADVANCED_ANALYSIS", "true").lower()
            self.enable_advanced_analysis = raw in {"1", "true", "yes", "on"}

        # -------------------------
        # Local timezone for as_of_local (mainly Riyadh)
        # -------------------------
        self.local_tz_name = os.getenv("LOCAL_TIMEZONE", "Asia/Riyadh")

        # -------------------------
        # Enabled global providers
        # -------------------------
        if enabled_providers is not None:
            providers = enabled_providers
        elif _SETTINGS is not None:
            providers = list(getattr(_SETTINGS, "enabled_providers", []) or [])
        else:
            raw = os.getenv("ENABLED_PROVIDERS", "fmp")
            providers = [p.strip().lower() for p in raw.split(",") if p.strip()]

        self.enabled_providers: List[str] = []
        for p in providers:
            p = p.lower()
            if p and p not in self.enabled_providers:
                self.enabled_providers.append(p)

        if not self.enabled_providers:
            self.enabled_providers = ["fmp"]

        # In-memory cache (simple, per-process)
        self._cache: Dict[str, _CacheEntry] = {}

        logger.info(
            "DataEngine v2.0 initialized (providers=%s, cache_ttl=%ss, timeout=%ss, v1_delegate=%s, advanced=%s)",
            self.enabled_providers,
            self.cache_ttl,
            self.provider_timeout,
            _HAS_V1_ENGINE,
            self.enable_advanced_analysis,
        )

    # --------------------------------------------------------
    # PUBLIC API
    # --------------------------------------------------------

    async def get_enriched_quote(self, symbol: str) -> UnifiedQuote:
        symbol_norm = self._normalize_symbol(symbol)
        if not symbol_norm:
            return UnifiedQuote(
                symbol="",
                data_quality="MISSING",
                error="Empty or invalid symbol",
            )

        now = time.time()
        cached = self._cache.get(symbol_norm)
        if cached and cached.expires_at > now:
            return cached.quote

        try:
            quote = await self._get_enriched_quote_uncached(symbol_norm)
        except Exception as exc:  # pragma: no cover - defensive
            logger.exception("DataEngine.get_enriched_quote exception for %s", symbol_norm)
            quote = UnifiedQuote(
                symbol=symbol_norm,
                data_quality="MISSING",
                error=f"Exception in DataEngine.get_enriched_quote: {exc}",
            )

        self._cache[symbol_norm] = _CacheEntry(
            expires_at=now + self.cache_ttl,
            quote=quote,
        )
        return quote

    async def get_enriched_quotes(self, symbols: List[str]) -> List[UnifiedQuote]:
        tasks = [self.get_enriched_quote(s) for s in symbols]
        return await asyncio.gather(*tasks)

    # --------------------------------------------------------
    # INTERNAL HELPERS
    # --------------------------------------------------------

    @staticmethod
    def _normalize_symbol(symbol: str) -> str:
        s = (symbol or "").strip().upper()
        if not s:
            return ""

        # Normalize Tadawul-style prefixes/suffixes
        if s.startswith("TADAWUL:"):
            s = s.split(":", 1)[1].strip()
        if s.endswith(".TADAWUL"):
            s = s.replace(".TADAWUL", ".SR")

        # Pure numeric -> assume Tadawul
        if s.isdigit():
            s = f"{s}.SR"

        return s

    @staticmethod
    def _is_ksa_symbol(symbol: str) -> bool:
        s = (symbol or "").upper()
        return s.endswith(".SR") or s.endswith(".TADAWUL")

    def _now_dt_pair(self) -> Tuple[datetime, Optional[datetime], Optional[str]]:
        now_utc = datetime.now(timezone.utc)
        as_of_local: Optional[datetime] = None
        tz_name: Optional[str] = None

        if ZoneInfo is not None:
            try:
                tz = ZoneInfo(self.local_tz_name)
                local_dt = now_utc.astimezone(tz)
                as_of_local = local_dt
                tz_name = self.local_tz_name
            except Exception:
                tz_name = None
                as_of_local = None

        return now_utc, as_of_local, tz_name

    # --------------------------------------------------------
    # CORE ENRICHMENT LOGIC
    # --------------------------------------------------------

    async def _get_enriched_quote_uncached(self, symbol: str) -> UnifiedQuote:
        is_ksa = self._is_ksa_symbol(symbol)

        # 1) KSA-safe delegate: if legacy core.data_engine is available, use it first
        #    This respects all Tadawul/Argaam routing you already have in v1.
        if is_ksa and _HAS_V1_ENGINE:
            try:
                v1_quotes = await _v1_engine.get_enriched_quotes([symbol])  # type: ignore[attr-defined]
                if v1_quotes:
                    logger.debug("Using v1 KSA delegate for %s", symbol)
                    return self._from_v1_quote(v1_quotes[0])
            except Exception as exc:  # pragma: no cover - defensive
                logger.exception("V1 KSA delegate failed for %s: %s", symbol, exc)

        # 2) Global providers (FMP / EODHD / Finnhub ...)
        providers = list(self.enabled_providers)

        # KSA-safe: never call EODHD for .SR / .TADAWUL symbols
        if is_ksa and "eodhd" in providers:
            providers = [p for p in providers if p != "eodhd"]
            logger.debug(
                "KSA-safe mode: removed EODHD from providers for %s -> %s",
                symbol,
                providers,
            )

        tasks: List[asyncio.Task[UnifiedQuote]] = []

        for provider in providers:
            provider = provider.lower()
            if provider == "fmp":
                tasks.append(
                    asyncio.create_task(
                        self._safe_call_provider("fmp", self._fetch_from_fmp, symbol)
                    )
                )
            elif provider == "eodhd":
                tasks.append(
                    asyncio.create_task(
                        self._safe_call_provider("eodhd", self._fetch_from_eodhd, symbol)
                    )
                )
            elif provider == "finnhub":
                tasks.append(
                    asyncio.create_task(
                        self._safe_call_provider(
                            "finnhub", self._fetch_from_finnhub, symbol
                        )
                    )
                )
            else:
                logger.warning("Unknown provider '%s' configured; ignoring", provider)

        if not tasks:
            return UnifiedQuote(
                symbol=symbol,
                data_quality="MISSING",
                error="No valid providers configured (ENABLED_PROVIDERS)",
            )

        results = await asyncio.gather(*tasks)

        # Prefer fully OK
        for q in results:
            if q.data_quality == "OK":
                return q

        # Then PARTIAL
        for q in results:
            if q.data_quality == "PARTIAL":
                return q

        # All failed
        combined_error = "; ".join([q.error for q in results if q.error])  # type: ignore
        return UnifiedQuote(
            symbol=symbol,
            data_quality="MISSING",
            error=combined_error or "All providers failed or returned no data",
        )

    async def _safe_call_provider(
        self,
        provider_name: str,
        func,
        symbol: str,
    ) -> UnifiedQuote:
        """
        Wrap a provider call with try/except so one provider crashing
        will not kill the whole engine.
        """
        try:
            q = await func(symbol)
            if q is None:
                return UnifiedQuote(
                    symbol=symbol,
                    data_quality="MISSING",
                    primary_provider=provider_name,
                    provider=provider_name,
                    data_source=provider_name,
                    error=f"{provider_name} returned no data",
                )
            q.primary_provider = q.primary_provider or provider_name
            q.provider = q.provider or provider_name
            q.data_source = q.data_source or provider_name
            return q
        except Exception as exc:
            logger.exception(
                "Provider '%s' exception for %s: %s", provider_name, symbol, exc
            )
            return UnifiedQuote(
                symbol=symbol,
                data_quality="MISSING",
                primary_provider=provider_name,
                provider=provider_name,
                data_source=provider_name,
                error=f"Provider {provider_name} exception: {exc}",
            )

    # --------------------------------------------------------
    # PROVIDER: FMP (Financial Modeling Prep)
    # --------------------------------------------------------

    async def _fetch_from_fmp(self, symbol: str) -> Optional[UnifiedQuote]:
        api_key = None
        if _SETTINGS is not None:
            api_key = getattr(_SETTINGS, "fmp_api_key", None)
        if not api_key:
            api_key = os.getenv("FMP_API_KEY")
        if not api_key:
            logger.warning("FMP_API_KEY not set; skipping FMP for %s", symbol)
            return None

        base_url = None
        if _SETTINGS is not None:
            base_url = getattr(_SETTINGS, "fmp_base_url", None)
        if not base_url:
            base_url = os.getenv(
                "FMP_BASE_URL", "https://financialmodelingprep.com/api/v3"
            )

        url = f"{base_url.rstrip('/')}/quote/{symbol}"

        async with httpx.AsyncClient(timeout=self.provider_timeout) as client:
            resp = await client.get(url, params={"apikey": api_key})
            resp.raise_for_status()
            data = resp.json()

        if not isinstance(data, list) or not data:
            return None

        raw = data[0]
        quote = self._map_fmp_to_unified(symbol, raw)
        quote.primary_provider = "fmp"
        quote.provider = "fmp"
        quote.data_source = "fmp"
        return quote

    def _map_fmp_to_unified(self, symbol: str, d: Dict[str, Any]) -> UnifiedQuote:
        def gv(*keys: str, default=None):
            for k in keys:
                if k in d and d[k] is not None:
                    return d[k]
            return default

        last_price = gv("price")
        previous_close = gv("previousClose")
        change = gv("change")
        change_pct = gv("changesPercentage")

        if change is None and last_price is not None and previous_close:
            try:
                change = float(last_price) - float(previous_close)
            except Exception:
                change = None

        if change_pct is None and change is not None and previous_close:
            try:
                change_pct = (float(change) / float(previous_close)) * 100.0
            except Exception:
                change_pct = None

        high_52w = gv("yearHigh")
        low_52w = gv("yearLow")
        position_52w = None
        if (
            high_52w is not None
            and low_52w is not None
            and last_price is not None
            and high_52w != low_52w
        ):
            try:
                position_52w = (float(last_price) - float(low_52w)) / (
                    float(high_52w) - float(low_52w)
                )
                position_52w *= 100.0
            except Exception:
                position_52w = None

        as_of_utc, as_of_local, tz_name = self._now_dt_pair()

        q = UnifiedQuote(
            symbol=str(gv("symbol", default=symbol)).upper(),
            name=gv("name"),
            company_name=gv("name"),
            market=gv("exchange"),
            market_region=gv("exchange"),
            exchange=gv("exchange"),
            currency=gv("currency"),
            last_price=last_price,
            price=last_price,
            previous_close=previous_close,
            prev_close=previous_close,
            open=gv("open"),
            high=gv("dayHigh"),
            low=gv("dayLow"),
            change=change,
            change_percent=change_pct,
            change_pct=change_pct,
            high_52w=high_52w,
            low_52w=low_52w,
            fifty_two_week_high=high_52w,
            fifty_two_week_low=low_52w,
            position_52w_percent=position_52w,
            fifty_two_week_position=position_52w,
            volume=gv("volume"),
            avg_volume_30d=gv("avgVolume"),
            average_volume_30d=gv("avgVolume"),
            avg_volume=gv("avgVolume"),
            market_cap=gv("marketCap"),
            eps_ttm=gv("eps"),
            eps=gv("eps"),
            pe_ratio=gv("pe"),
            pe=gv("pe"),
            pe_ttm=gv("pe"),
            beta=gv("beta"),
            ma_50d=gv("priceAvg50"),
            data_quality="OK" if last_price is not None else "PARTIAL",
            last_updated_utc=as_of_utc,
            last_updated_riyadh=as_of_local,
            as_of_utc=as_of_utc,
            as_of_local=as_of_local,
            timezone=tz_name,
            raw=d,
        )

        if self.enable_advanced_analysis:
            self._apply_basic_scoring(q, source="fmp")

        return q

    # --------------------------------------------------------
    # PROVIDER: EODHD (Global, but NEVER for KSA .SR)
    # --------------------------------------------------------

    async def _fetch_from_eodhd(self, symbol: str) -> Optional[UnifiedQuote]:
        api_key = None
        if _SETTINGS is not None:
            api_key = getattr(_SETTINGS, "eodhd_api_key", None)
        if not api_key:
            api_key = os.getenv("EODHD_API_KEY")

        base_url = None
        if _SETTINGS is not None:
            base_url = getattr(_SETTINGS, "eodhd_base_url", None)
        if not base_url:
            base_url = os.getenv("EODHD_BASE_URL", "https://eodhd.com/api")

        if not api_key:
            logger.warning("EODHD_API_KEY not set; skipping EODHD for %s", symbol)
            return None

        url = f"{base_url.rstrip('/')}/real-time/{symbol}"
        params = {"api_token": api_key, "fmt": "json"}

        async with httpx.AsyncClient(timeout=self.provider_timeout) as client:
            resp = await client.get(url, params=params)
            resp.raise_for_status()
            d = resp.json()

        if not isinstance(d, dict) or not d:
            return None

        q = self._map_eodhd_to_unified(symbol, d)
        q.primary_provider = "eodhd"
        q.provider = "eodhd"
        q.data_source = "eodhd"
        return q

    def _map_eodhd_to_unified(self, symbol: str, d: Dict[str, Any]) -> UnifiedQuote:
        def gv(*keys: str, default=None):
            for k in keys:
                if k in d and d[k] is not None:
                    return d[k]
            return default

        last_price = gv("close", "price", "last")
        previous_close = gv("previousClose", "previous_close")
        change = gv("change")
        change_pct = gv("change_p", "change_percent")

        if change is None and last_price is not None and previous_close:
            try:
                change = float(last_price) - float(previous_close)
            except Exception:
                change = None

        if change_pct is None and change is not None and previous_close:
            try:
                change_pct = (float(change) / float(previous_close)) * 100.0
            except Exception:
                change_pct = None

        high_52w = gv("fifty_two_week_high", "high_52w")
        low_52w = gv("fifty_two_week_low", "low_52w")
        position_52w = gv("fifty_two_week_position", "position_52w_percent")

        if (
            position_52w is None
            and high_52w is not None
            and low_52w is not None
            and last_price is not None
            and high_52w != low_52w
        ):
            try:
                position_52w = (float(last_price) - float(low_52w)) / (
                    float(high_52w) - float(low_52w)
                )
                position_52w *= 100.0
            except Exception:
                position_52w = None

        as_of_utc, as_of_local, tz_name = self._now_dt_pair()

        q = UnifiedQuote(
            symbol=str(gv("code", "symbol", default=symbol)).upper(),
            name=gv("name"),
            company_name=gv("name"),
            market=gv("exchange_short_name", "exchange"),
            market_region=gv("exchange_short_name", "exchange"),
            exchange=gv("exchange_short_name", "exchange"),
            currency=gv("currency", "currency_code"),
            last_price=last_price,
            price=last_price,
            previous_close=previous_close,
            prev_close=previous_close,
            open=gv("open"),
            high=gv("high"),
            low=gv("low"),
            change=change,
            change_percent=change_pct,
            change_pct=change_pct,
            high_52w=high_52w,
            low_52w=low_52w,
            fifty_two_week_high=high_52w,
            fifty_two_week_low=low_52w,
            position_52w_percent=position_52w,
            fifty_two_week_position=position_52w,
            volume=gv("volume"),
            data_quality="OK" if last_price is not None else "PARTIAL",
            last_updated_utc=as_of_utc,
            last_updated_riyadh=as_of_local,
            as_of_utc=as_of_utc,
            as_of_local=as_of_local,
            timezone=tz_name,
            raw=d,
        )

        if self.enable_advanced_analysis:
            self._apply_basic_scoring(q, source="eodhd")

        return q

    # --------------------------------------------------------
    # PROVIDER: Finnhub (mainly price / intraday)
    # --------------------------------------------------------

    async def _fetch_from_finnhub(self, symbol: str) -> Optional[UnifiedQuote]:
        api_key = None
        if _SETTINGS is not None:
            api_key = getattr(_SETTINGS, "finnhub_api_key", None)
        if not api_key:
            api_key = os.getenv("FINNHUB_API_KEY")

        if not api_key:
            logger.warning("FINNHUB_API_KEY not set; skipping Finnhub for %s", symbol)
            return None

        url = "https://finnhub.io/api/v1/quote"
        params = {"symbol": symbol, "token": api_key}

        async with httpx.AsyncClient(timeout=self.provider_timeout) as client:
            resp = await client.get(url, params=params)
            resp.raise_for_status()
            d = resp.json()

        if not isinstance(d, dict) or not d:
            return None

        last_price = d.get("c")
        previous_close = d.get("pc")
        open_price = d.get("o")
        high = d.get("h")
        low = d.get("l")

        change = None
        change_pct = None
        if last_price is not None and previous_close:
            try:
                change = float(last_price) - float(previous_close)
                change_pct = (float(change) / float(previous_close)) * 100.0
            except Exception:
                change = None
                change_pct = None

        as_of_utc, as_of_local, tz_name = self._now_dt_pair()

        q = UnifiedQuote(
            symbol=symbol.upper(),
            last_price=last_price,
            price=last_price,
            previous_close=previous_close,
            prev_close=previous_close,
            open=open_price,
            high=high,
            low=low,
            change=change,
            change_percent=change_pct,
            change_pct=change_pct,
            volume=None,
            data_quality="PARTIAL" if last_price is not None else "MISSING",
            last_updated_utc=as_of_utc,
            last_updated_riyadh=as_of_local,
            as_of_utc=as_of_utc,
            as_of_local=as_of_local,
            timezone=tz_name,
            raw=d,
        )

        if self.enable_advanced_analysis:
            self._apply_basic_scoring(q, source="finnhub")

        return q

    # --------------------------------------------------------
    # V1 DELEGATE CONVERSION (KSA-safe path)
    # --------------------------------------------------------

    def _from_v1_quote(self, v1_q: Any) -> UnifiedQuote:
        """
        Convert whatever core.data_engine.get_enriched_quotes returns
        (for one symbol) into the v2 UnifiedQuote model.
        """

        def gv(*names: str, default=None):
            for n in names:
                if hasattr(v1_q, n):
                    val = getattr(v1_q, n)
                    if val is not None:
                        return val
            return default

        symbol = (gv("symbol", "ticker", default="") or "").upper()
        name = gv("company_name", "name")
        sector = gv("sector")
        sub_sector = gv("sub_sector", "industry_group")
        industry = gv("industry")
        market = gv("market", "market_region", "exchange")
        market_region = gv("market_region", "market")
        exchange = gv("exchange")
        currency = gv("currency")

        last_price = gv("price", "last_price")
        previous_close = gv("prev_close", "previous_close")
        open_price = gv("open")
        high = gv("high")
        low = gv("low")
        change = gv("change")
        change_pct = gv("change_pct", "change_percent")

        high_52w = gv("fifty_two_week_high", "high_52w")
        low_52w = gv("fifty_two_week_low", "low_52w")
        pos_52w = gv("fifty_two_week_position", "position_52w_percent")

        volume = gv("volume")
        avg_volume = gv("avg_volume", "avg_volume_30d")
        market_cap = gv("market_cap")
        shares_outstanding = gv("shares_outstanding")
        free_float = gv("free_float")

        eps_ttm = gv("eps_ttm", "eps")
        pe_ttm = gv("pe_ttm", "pe", "pe_ratio")
        pb = gv("pb", "pb_ratio")
        dividend_yield = gv("dividend_yield", "dividend_yield_percent")
        roe = gv("roe")
        roa = gv("roa")
        profit_margin = gv("profit_margin", "net_margin_percent")
        debt_to_equity = gv("debt_to_equity")

        data_quality = gv("data_quality", default="UNKNOWN")
        sources = gv("sources")
        last_updated_utc = gv("last_updated_utc")
        last_updated_riyadh = gv("last_updated_riyadh", "last_updated_local")

        as_of_utc = last_updated_utc
        as_of_local = last_updated_riyadh
        tz_name = gv("timezone")

        if last_updated_utc is None:
            as_of_utc, as_of_local, tz_name = self._now_dt_pair()
            last_updated_utc = as_of_utc
            last_updated_riyadh = as_of_local

        provider = None
        primary_provider = None
        provider_sources: Optional[List[ProviderSource]] = None

        if sources:
            try:
                if isinstance(sources, list) and sources:
                    tmp_sources: List[ProviderSource] = []
                    for s in sources:
                        if isinstance(s, dict):
                            prov = str(
                                s.get("provider")
                                or s.get("name")
                                or s.get("source")
                                or ""
                            )
                            tmp_sources.append(
                                ProviderSource(
                                    provider=prov,
                                    weight=s.get("weight"),
                                    quality=s.get("quality"),
                                )
                            )
                        else:
                            prov = str(
                                getattr(s, "provider", None)
                                or getattr(s, "name", None)
                                or getattr(s, "source", None)
                                or ""
                            )
                            tmp_sources.append(
                                ProviderSource(
                                    provider=prov,
                                    weight=getattr(s, "weight", None),
                                    quality=getattr(s, "quality", None),
                                )
                            )
                    provider_sources = tmp_sources
                    if tmp_sources:
                        primary_provider = tmp_sources[0].provider
                        provider = primary_provider
            except Exception:
                provider_sources = None
                provider = None
                primary_provider = None

        q = UnifiedQuote(
            symbol=symbol,
            name=name,
            company_name=name,
            sector=sector,
            sub_sector=sub_sector,
            industry=industry,
            market=market,
            market_region=market_region,
            exchange=exchange,
            currency=currency,
            shares_outstanding=shares_outstanding,
            free_float=free_float,
            last_price=last_price,
            price=last_price,
            previous_close=previous_close,
            prev_close=previous_close,
            open=open_price,
            high=high,
            low=low,
            change=change,
            change_percent=change_pct,
            change_pct=change_pct,
            high_52w=high_52w,
            low_52w=low_52w,
            fifty_two_week_high=high_52w,
            fifty_two_week_low=low_52w,
            position_52w_percent=pos_52w,
            fifty_two_week_position=pos_52w,
            volume=volume,
            avg_volume_30d=avg_volume,
            average_volume_30d=avg_volume,
            avg_volume=avg_volume,
            market_cap=market_cap,
            eps_ttm=eps_ttm,
            eps=eps_ttm,
            pe_ratio=pe_ttm,
            pe=pe_ttm,
            pe_ttm=pe_ttm,
            pb_ratio=pb,
            pb=pb,
            dividend_yield=dividend_yield,
            dividend_yield_percent=dividend_yield,
            roe=roe,
            roe_percent=roe,
            roa=roa,
            roa_percent=roa,
            profit_margin=profit_margin,
            net_margin_percent=profit_margin,
            debt_to_equity=debt_to_equity,
            data_quality=data_quality,
            primary_provider=primary_provider,
            provider=provider,
            data_source=provider,
            sources=provider_sources,
            last_updated_utc=last_updated_utc,
            last_updated_riyadh=last_updated_riyadh,
            as_of_utc=as_of_utc,
            as_of_local=as_of_local,
            timezone=tz_name,
            raw=None,
        )

        if self.enable_advanced_analysis:
            self._apply_basic_scoring(q, source="v1_delegate")

        return q

    # --------------------------------------------------------
    # BASIC AI SCORING (Value / Quality / Momentum / Opportunity)
    # --------------------------------------------------------

    def _apply_basic_scoring(self, q: UnifiedQuote, source: str) -> None:
        """
        Lightweight, deterministic scoring – no external ML.
        This is safe for production and deterministic for Google Sheets.
        """

        quality = 50.0
        pe = q.pe_ratio or q.pe or q.pe_ttm
        eps = q.eps_ttm or q.eps

        # very rough quality scoring based on earnings + PE
        if eps is not None and eps > 0 and pe is not None and pe > 0:
            if pe < 10:
                quality = 80.0
            elif pe < 20:
                quality = 70.0
            elif pe < 30:
                quality = 60.0
            else:
                quality = 50.0
        elif eps is not None and eps <= 0:
            quality = 30.0

        # value score – lower PE and healthy dividend => better
        value = 50.0
        if pe is not None and pe > 0:
            try:
                value = max(10.0, min(90.0, 100.0 / (1.0 + pe / 10.0)))
            except Exception:
                value = 50.0

        dy = q.dividend_yield_percent or q.dividend_yield
        if dy is not None and dy > 0:
            try:
                value = min(90.0, value + min(20.0, float(dy)))
            except Exception:
                pass

        # momentum score – based on daily change and 52w position
        momentum = 50.0
        cp_source = q.change_percent if q.change_percent is not None else q.change_pct
        if cp_source is not None:
            try:
                cp = float(cp_source)
                momentum += max(-20.0, min(20.0, cp))
            except Exception:
                pass

        if q.position_52w_percent is not None:
            try:
                p = float(q.position_52w_percent)
                if p > 80:
                    momentum += 5.0
                elif p < 20:
                    momentum -= 5.0
            except Exception:
                pass

        # clamp 0–100
        value = max(0.0, min(100.0, value))
        quality = max(0.0, min(100.0, quality))
        momentum = max(0.0, min(100.0, momentum))

        opportunity = value * 0.4 + quality * 0.3 + momentum * 0.3

        q.value_score = round(value, 2)
        q.quality_score = round(quality, 2)
        q.momentum_score = round(momentum, 2)
        q.opportunity_score = round(opportunity, 2)

        # basic recommendation buckets
        if opportunity >= 80:
            q.recommendation = "STRONG_BUY"
        elif opportunity >= 65:
            q.recommendation = "BUY"
        elif opportunity >= 50:
            q.recommendation = "HOLD"
        elif opportunity >= 35:
            q.recommendation = "REDUCE"
        else:
            q.recommendation = "SELL"

        # valuation label based on value_score
        if q.value_score is not None:
            if q.value_score >= 80:
                q.valuation_label = "DEEP_VALUE"
            elif q.value_score >= 65:
                q.valuation_label = "UNDERVALUED"
            elif q.value_score >= 45:
                q.valuation_label = "FAIR_VALUE"
            else:
                q.valuation_label = "EXPENSIVE"


__all__ = ["UnifiedQuote", "ProviderSource", "DataEngine"]
