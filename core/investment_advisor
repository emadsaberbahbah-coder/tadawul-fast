# core/investment_advisor.py
# Tadawul Fast Bridge â€” Investment Advisor Core
# Version: 0.1.0
#
# Contract:
#   run_investment_advisor(payload_dict) -> {"headers": [...], "rows": [...], "meta": {...}}
#
# Notes:
# - Safe, defensive parsing for sheet rows.
# - Works even if some columns are missing (it will degrade gracefully).
# - Integrates with core/data_engine_v2.py if functions exist, otherwise returns a clear error.
#
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple
import math
import time


TT_ADVISOR_CORE_VERSION = "0.1.0"


# -----------------------------------------------------------------------------
# Optional dependency: data_engine_v2
# -----------------------------------------------------------------------------
def _try_get_universe_rows(
    sources: List[str],
    *,
    max_rows_per_source: int = 5000,
) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
    """
    Returns:
      - rows: list of dict rows (normalized)
      - meta: diagnostics

    Expected data_engine_v2 capability (preferred, but optional):
      - get_cached_sheet_rows(sheet_name: str) -> {"headers": [...], "rows": [[...], ...], "meta": {...}}
        OR
      - get_cached_pages(pages: list[str]) -> {"items": [ { "sheet": "...", "headers": [...], "rows": [...] }, ... ]}

    If not available, we raise a RuntimeError with a clear message.
    """
    meta: Dict[str, Any] = {"sources": sources, "engine": None, "items": []}

    try:
        # You said you'll revise this later; we try to plug in without forcing a specific signature.
        import core.data_engine_v2 as de  # type: ignore
    except Exception as exc:
        raise RuntimeError(
            "data_engine_v2 is not available. Please add/enable core/data_engine_v2.py caching access."
        ) from exc

    # Map "ALL" to your pages
    normalized_sources = [s.strip() for s in sources if isinstance(s, str) and s.strip()]
    if not normalized_sources:
        normalized_sources = ["ALL"]

    if "ALL" in [s.upper() for s in normalized_sources]:
        normalized_sources = ["Market_Leaders", "Global_Markets", "Mutual_Funds", "Commodities_FX"]

    meta["engine"] = getattr(de, "__name__", "core.data_engine_v2")
    out_rows: List[Dict[str, Any]] = []

    # Strategy A: get_cached_pages(pages)
    if hasattr(de, "get_cached_pages"):
        resp = de.get_cached_pages(normalized_sources)  # type: ignore
        items = resp.get("items", []) if isinstance(resp, dict) else []
        for it in items:
            sheet = it.get("sheet") or it.get("name") or "UNKNOWN"
            headers = it.get("headers") or []
            rows = it.get("rows") or []
            meta["items"].append({"sheet": sheet, "rows": len(rows), "headers": len(headers)})
            out_rows.extend(_rows_to_dicts(headers, rows, sheet_name=str(sheet), limit=max_rows_per_source))
        return out_rows, meta

    # Strategy B: per-sheet getter: get_cached_sheet_rows(sheet)
    if hasattr(de, "get_cached_sheet_rows"):
        for sheet in normalized_sources:
            resp = de.get_cached_sheet_rows(sheet)  # type: ignore
            if not isinstance(resp, dict):
                continue
            headers = resp.get("headers") or []
            rows = resp.get("rows") or []
            meta["items"].append({"sheet": sheet, "rows": len(rows), "headers": len(headers)})
            out_rows.extend(_rows_to_dicts(headers, rows, sheet_name=sheet, limit=max_rows_per_source))
        return out_rows, meta

    raise RuntimeError(
        "data_engine_v2 does not expose get_cached_pages(...) or get_cached_sheet_rows(...). "
        "Please revise core/data_engine_v2.py accordingly."
    )


def _rows_to_dicts(headers: List[Any], rows: List[Any], sheet_name: str, limit: int) -> List[Dict[str, Any]]:
    h = [str(x).strip() for x in (headers or [])]
    out: List[Dict[str, Any]] = []
    for r_i, r in enumerate(rows or []):
        if r_i >= limit:
            break
        if not isinstance(r, list):
            continue
        d = {h[c_i]: r[c_i] if c_i < len(r) else None for c_i in range(len(h))}
        d["_Sheet"] = sheet_name
        out.append(d)
    return out


# -----------------------------------------------------------------------------
# Helpers: parsing + normalization
# -----------------------------------------------------------------------------
def _to_float(x: Any) -> Optional[float]:
    if x is None:
        return None
    if isinstance(x, (int, float)):
        if math.isnan(x) if isinstance(x, float) else False:
            return None
        return float(x)
    if isinstance(x, str):
        s = x.strip().replace(",", "")
        if s in ("", "NA", "N/A", "null", "None", "-"):
            return None
        # handle +1.23%
        s = s.replace("%", "")
        try:
            return float(s)
        except Exception:
            return None
    return None


def _to_int(x: Any) -> Optional[int]:
    f = _to_float(x)
    if f is None:
        return None
    try:
        return int(round(f))
    except Exception:
        return None


def _norm_bucket(x: Any) -> str:
    if not isinstance(x, str):
        return ""
    s = x.strip().lower()
    # normalize common forms
    if s in ("low", "low risk", "low-risk", "conservative"):
        return "Low"
    if s in ("moderate", "medium", "mid", "balanced"):
        return "Moderate"
    if s in ("high", "aggressive", "high risk", "high-risk"):
        return "High"
    if s in ("very high", "very-high", "speculative"):
        return "Very High"
    # Confidence
    if s in ("high confidence", "high-conf", "highconf"):
        return "High"
    if s in ("moderate confidence", "medium confidence", "mid confidence"):
        return "Moderate"
    if s in ("low confidence", "low-conf"):
        return "Low"
    return x.strip().title()


def _as_ratio(x: Any) -> Optional[float]:
    """
    Accepts:
      - 0.10 => 10%
      - 10   => 10% (treated as percent)
      - "10%" => 10%
    Returns ratio (0.10) or None
    """
    f = _to_float(x)
    if f is None:
        return None
    # If user passes 10 or 25, treat as percent
    if f > 1.5:
        return f / 100.0
    return f


def _safe_str(x: Any) -> str:
    return "" if x is None else str(x).strip()


# -----------------------------------------------------------------------------
# Scoring model (simple + stable)
# -----------------------------------------------------------------------------
@dataclass
class Candidate:
    symbol: str
    name: str
    sheet: str
    price: Optional[float]
    risk_bucket: str
    confidence_bucket: str

    forecast_1m: Optional[float]
    exp_roi_1m: Optional[float]  # ratio
    forecast_3m: Optional[float]
    exp_roi_3m: Optional[float]  # ratio

    overall_score: Optional[float]  # 0-100 if exists
    risk_score: Optional[float]     # 0-100 if exists (lower = safer in many models)
    momentum_score: Optional[float] # 0-100
    value_score: Optional[float]    # 0-100
    quality_score: Optional[float]  # 0-100

    # derived
    advisor_score: float = 0.0
    reason: str = ""


def _extract_candidate(row: Dict[str, Any]) -> Optional[Candidate]:
    # Flexible headers: we try multiple options
    symbol = _safe_str(row.get("Symbol") or row.get("Fund Symbol") or row.get("Ticker") or row.get("Code"))
    if not symbol:
        return None

    name = _safe_str(row.get("Name") or row.get("Company Name") or row.get("Fund Name") or row.get("Instrument"))
    sheet = _safe_str(row.get("_Sheet") or row.get("Origin") or "")

    price = _to_float(row.get("Price") or row.get("Last") or row.get("Close") or row.get("NAV per Share"))

    risk_bucket = _norm_bucket(row.get("Risk Bucket") or row.get("Risk") or row.get("Risk Level") or "")
    confidence_bucket = _norm_bucket(row.get("Confidence Bucket") or row.get("Confidence") or "")

    # Forecast / ROI columns (your sheets already have these)
    forecast_1m = _to_float(row.get("Forecast Price (1M)") or row.get("Forecast Price 1M") or row.get("Forecast 1M"))
    exp_roi_1m = _as_ratio(row.get("Expected ROI % (1M)") or row.get("Expected ROI 1M") or row.get("ROI 1M"))

    forecast_3m = _to_float(row.get("Forecast Price (3M)") or row.get("Forecast Price 3M") or row.get("Forecast 3M"))
    exp_roi_3m = _as_ratio(row.get("Expected ROI % (3M)") or row.get("Expected ROI 3M") or row.get("ROI 3M"))

    overall_score = _to_float(row.get("Overall Score") or row.get("Opportunity Score") or row.get("Score"))
    risk_score = _to_float(row.get("Risk Score"))
    momentum_score = _to_float(row.get("Momentum Score"))
    value_score = _to_float(row.get("Value Score"))
    quality_score = _to_float(row.get("Quality Score"))

    return Candidate(
        symbol=symbol,
        name=name,
        sheet=sheet,
        price=price,
        risk_bucket=risk_bucket,
        confidence_bucket=confidence_bucket,
        forecast_1m=forecast_1m,
        exp_roi_1m=exp_roi_1m,
        forecast_3m=forecast_3m,
        exp_roi_3m=exp_roi_3m,
        overall_score=overall_score,
        risk_score=risk_score,
        momentum_score=momentum_score,
        value_score=value_score,
        quality_score=quality_score,
    )


def _passes_filters(
    c: Candidate,
    risk: str,
    confidence: str,
    req_roi_1m: Optional[float],
    req_roi_3m: Optional[float],
) -> Tuple[bool, str]:
    # Risk/Confidence are dropdown filters: if blank, do not filter.
    if risk and c.risk_bucket and _norm_bucket(risk) != _norm_bucket(c.risk_bucket):
        return False, "Risk filter"
    if confidence and c.confidence_bucket and _norm_bucket(confidence) != _norm_bucket(c.confidence_bucket):
        return False, "Confidence filter"

    # ROI filters: pass if ROI exists and meets required; if ROI missing, fail (conservative)
    if req_roi_1m is not None:
        if c.exp_roi_1m is None or c.exp_roi_1m < req_roi_1m:
            return False, "ROI 1M"
    if req_roi_3m is not None:
        if c.exp_roi_3m is None or c.exp_roi_3m < req_roi_3m:
            return False, "ROI 3M"

    return True, ""


def _compute_advisor_score(c: Candidate, req_roi_1m: Optional[float], req_roi_3m: Optional[float]) -> Tuple[float, str]:
    """
    Stable, explainable scoring:
    - Base = Overall Score if exists else 50
    - ROI boosts (1M/3M): reward ROI above thresholds
    - Quality/Momentum/Value: small boosts if exist
    - Risk Score: if exists, penalize higher risk (assume higher = riskier)
    """
    base = c.overall_score if c.overall_score is not None else 50.0
    score = float(base)

    reasons: List[str] = []

    # ROI reward
    if c.exp_roi_1m is not None:
        thr = req_roi_1m if req_roi_1m is not None else 0.0
        uplift = max(0.0, (c.exp_roi_1m - thr)) * 100.0  # convert to points scale
        score += min(15.0, uplift * 0.4)
        reasons.append(f"ROI1M={c.exp_roi_1m:.2%}")

    if c.exp_roi_3m is not None:
        thr = req_roi_3m if req_roi_3m is not None else 0.0
        uplift = max(0.0, (c.exp_roi_3m - thr)) * 100.0
        score += min(20.0, uplift * 0.35)
        reasons.append(f"ROI3M={c.exp_roi_3m:.2%}")

    # Factor boosts
    for label, val, cap, weight in (
        ("Quality", c.quality_score, 6.0, 0.06),
        ("Momentum", c.momentum_score, 6.0, 0.06),
        ("Value", c.value_score, 6.0, 0.06),
    ):
        if val is not None:
            score += min(cap, max(0.0, val) * weight)
            reasons.append(f"{label}={val:.1f}")

    # Risk penalty
    if c.risk_score is not None:
        # If risk_score is 0-100, penalize above 50 mildly
        penalty = max(0.0, c.risk_score - 50.0) * 0.10
        score -= min(12.0, penalty)
        reasons.append(f"RiskScore={c.risk_score:.1f}")

    # Clamp
    score = max(0.0, min(100.0, score))
    return score, "; ".join(reasons[:6])


# -----------------------------------------------------------------------------
# Allocation
# -----------------------------------------------------------------------------
def _allocate_amount(
    ranked: List[Candidate],
    total_amount: float,
    top_n: int,
) -> List[Dict[str, Any]]:
    """
    Simple robust allocator:
    - Use top_n candidates
    - Weight by normalized advisor_score (softmax-ish but simple)
    - Ensure minimum allocation if possible
    Returns list with allocation details.
    """
    picks = ranked[: max(0, int(top_n))]
    if not picks:
        return []

    # If total_amount is 0, allocate 0
    total_amount = float(total_amount or 0.0)
    if total_amount <= 0:
        return [{"symbol": c.symbol, "weight": 0.0, "amount": 0.0} for c in picks]

    scores = [max(1.0, c.advisor_score) for c in picks]  # avoid zero weights
    ssum = sum(scores)
    weights = [s / ssum for s in scores]

    # Optional: enforce a small minimum allocation (1% of total) if enough budget
    min_amt = total_amount * 0.01
    # If enforcing min breaks budget, skip min enforcement
    if min_amt * len(picks) > total_amount:
        min_amt = 0.0

    # Start with min allocations
    alloc_amounts = [min_amt for _ in picks]
    remaining = total_amount - sum(alloc_amounts)

    # Distribute remaining by weights
    if remaining > 0:
        for i, w in enumerate(weights):
            alloc_amounts[i] += remaining * w

    # Final normalization for rounding drift
    drift = total_amount - sum(alloc_amounts)
    if abs(drift) > 1e-6:
        alloc_amounts[0] += drift

    out = []
    for c, w, a in zip(picks, weights, alloc_amounts):
        out.append({"symbol": c.symbol, "weight": w, "amount": a})
    return out


# -----------------------------------------------------------------------------
# Public entry point
# -----------------------------------------------------------------------------
def run_investment_advisor(payload: Dict[str, Any]) -> Dict[str, Any]:
    """
    payload keys expected (from routes fallback or schemas later):
      - sources: list[str] or ["ALL"]
      - risk: str
      - confidence: str
      - required_roi_1m: float (ratio or percent)
      - required_roi_3m: float (ratio or percent)
      - top_n: int
      - invest_amount: float
      - include_news: bool (unused here; will be used when core/news_intelligence.py is added)
    """
    t0 = time.time()

    sources = payload.get("sources") or ["ALL"]
    if isinstance(sources, str):
        sources = [sources]
    sources = [str(s).strip() for s in sources if str(s).strip()] or ["ALL"]

    risk = _norm_bucket(payload.get("risk") or "")
    confidence = _norm_bucket(payload.get("confidence") or "")

    req_roi_1m = _as_ratio(payload.get("required_roi_1m"))
    req_roi_3m = _as_ratio(payload.get("required_roi_3m"))

    top_n = _to_int(payload.get("top_n")) or 10
    top_n = max(1, min(200, top_n))

    invest_amount = _to_float(payload.get("invest_amount")) or 0.0
    currency = _safe_str(payload.get("currency") or "SAR")

    include_news = bool(payload.get("include_news", True))  # placeholder for script #3

    # 1) Fetch universe from cached engine
    universe_rows, fetch_meta = _try_get_universe_rows(sources)

    # 2) Extract candidates
    candidates: List[Candidate] = []
    dropped = {"no_symbol": 0, "filter": 0, "bad_row": 0}
    for r in universe_rows:
        try:
            c = _extract_candidate(r)
            if c is None:
                dropped["no_symbol"] += 1
                continue

            ok, reason = _passes_filters(c, risk, confidence, req_roi_1m, req_roi_3m)
            if not ok:
                dropped["filter"] += 1
                continue

            c.advisor_score, c.reason = _compute_advisor_score(c, req_roi_1m, req_roi_3m)
            candidates.append(c)
        except Exception:
            dropped["bad_row"] += 1
            continue

    # 3) Rank
    candidates.sort(key=lambda x: (x.advisor_score, (x.exp_roi_3m or 0.0), (x.exp_roi_1m or 0.0)), reverse=True)

    # 4) Allocate
    allocations = _allocate_amount(candidates, invest_amount, top_n)
    alloc_map = {a["symbol"]: a for a in allocations}

    # 5) Build Sheets-ready output
    headers = [
        "Rank",
        "Symbol",
        "Name",
        "Source Sheet",
        "Price",
        "Risk Bucket",
        "Confidence Bucket",
        "Advisor Score",
        "Expected ROI % (1M)",
        "Forecast Price (1M)",
        "Expected ROI % (3M)",
        "Forecast Price (3M)",
        "Weight",
        f"Allocated Amount ({currency})",
        f"Expected Gain/Loss 1M ({currency})",
        f"Expected Gain/Loss 3M ({currency})",
        "Reason (Explain)",
    ]

    rows: List[List[Any]] = []
    for i, c in enumerate(candidates[:top_n], start=1):
        alloc = alloc_map.get(c.symbol, {"weight": 0.0, "amount": 0.0})
        amt = float(alloc.get("amount", 0.0) or 0.0)
        w = float(alloc.get("weight", 0.0) or 0.0)

        # Expected gain/loss = allocated amount * expected ROI (ratio)
        gl_1m = amt * (c.exp_roi_1m if c.exp_roi_1m is not None else 0.0)
        gl_3m = amt * (c.exp_roi_3m if c.exp_roi_3m is not None else 0.0)

        rows.append(
            [
                i,
                c.symbol,
                c.name,
                c.sheet,
                c.price,
                c.risk_bucket,
                c.confidence_bucket,
                round(c.advisor_score, 2),
                (c.exp_roi_1m * 100.0) if c.exp_roi_1m is not None else None,
                c.forecast_1m,
                (c.exp_roi_3m * 100.0) if c.exp_roi_3m is not None else None,
                c.forecast_3m,
                round(w, 6),
                round(amt, 2),
                round(gl_1m, 2),
                round(gl_3m, 2),
                c.reason,
            ]
        )

    meta = {
        "ok": True,
        "core_version": TT_ADVISOR_CORE_VERSION,
        "include_news": include_news,
        "criteria": {
            "sources": sources,
            "risk": risk,
            "confidence": confidence,
            "required_roi_1m_ratio": req_roi_1m,
            "required_roi_3m_ratio": req_roi_3m,
            "top_n": top_n,
            "invest_amount": invest_amount,
            "currency": currency,
        },
        "fetch": fetch_meta,
        "counts": {
            "universe_rows": len(universe_rows),
            "candidates_after_filters": len(candidates),
            "dropped": dropped,
        },
        "runtime_ms": int((time.time() - t0) * 1000),
    }

    # If nothing matched, still return stable headers for GAS safety
    if not rows:
        meta["warning"] = "No candidates matched your filters/ROI thresholds."

    return {"headers": headers, "rows": rows, "meta": meta}
